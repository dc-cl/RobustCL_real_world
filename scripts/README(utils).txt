系统作用：

class TopicSubscriber ：这个类的主要功能是订阅一个特定的 ROS 话题，接收并处理 LinktrackNodeframe2 类型的消息，提取并存储节点的距离数据
具体解释如下：
1、初始化 ROS 节点：anonymous=False 用于保持节点实例名称可见，以便在调试时识别。
2、订阅话题：话题类型为 LinktrackNodeframe2，这意味着订阅器将接收这种类型的消息。
3、处理消息回调：回调函数将遍历消息中的 nodes 数组，并将每个 node 的 dis 属性值添加到 self.dis_list 列表中。
4、运行循环

init ：该函数主要用于初始化每个robo的状态矩阵和协方差矩阵、每个机器人实机运动所需要的参数
具体解释如下:
1、创建ROS参数:
/start_time: 用于存储程序的启动时间。
/broadcast_comm_his_GS: 用于存储所有机器人的通信历史，用于记录每个机器人是否已完成初始化
2、初始化过程:
（1）判断参数存在：代码首先检查/broadcast_comm_his_GS参数是否已在ROS参数服务器中创建，如果没有则创建一个默认值（一个全零列表），并将其设置为每个机器人自身的通信次数为1。此操作确保了每个机器人在初始化时都记录了自身的通信状态。
（2）参数锁机制：在更新/broadcast_comm_his_GS参数时，代码使用了参数锁/broadcast_comm_his_GS_lock来确保在同一时间只有一个客户端可以更新该参数。这有助于避免在多机器人系统中出现的并发更新问题，保证系统的同步性和稳定性。
（3）遍历检查：代码遍历/broadcast_comm_his_GS列表，检查所有机器人的通信次数是否都大于0。这表示所有机器人都已完成了初始化，并且可以开始执行后续操作。
（4）设置启动时间：当所有机器人完成初始化后，代码将计算一个启动时间（延迟5秒），将此时间作为参数/start_time存储。这为后续的操作提供了一个时间基准。
（5）持久化参数:rospy.set_param：在每次更新或检查参数之后，代码都会调用rospy.set_param函数，确保参数持久存储在ROS参数服务器中，供后续使用。


motion ：该函数实现了多机器人系统中基于随机生成速度和时间控制的动态运动控制，确保每个机器人按照预定的循环和随机速度执行运动
具体解释如下：
1、初始化和等待所有机器人就绪:通过rospy.get_param(str_start_time)获取ROS参数服务器中存储的系统启动时间。利用循环和rospy.sleep(0.1)等待所有机器人完成初始化，确保所有机器人在执行运动前都处于就绪状态。
2、设置运动开始和结束时间:初始化运动开始时间next_motion_time为系统启动时间，并设定总运动时间final_time。
3、生成随机速度:使用np.random.randn()生成随机的线速度和角速度，通过velocity计算。
随机速度考虑了可能的输入噪声和环境因素。
4、执行运动循环:
（1）使用v_all_lock对共享数据进行锁操作，确保在向v_all数组添加新的速度数据时不会发生并发访问问题。
（2）将计算出的速度存储到v_all数组中，每执行完一个运动周期，更新v_count以记录运动次数。
定义vel_pub用于发布控制命令到机器人，通过vel_msg设置当前周期的速度，并通过vel_pub.publish(vel_msg)执行运动。
（3）在运动周期开始时，通过vel_msg.angular.z和vel_msg.linear.x设置机器人的转速和线速度。
调整速度的时间间隔以确保稳定运动，最后通过设置vel_msg.linear.x = 0和vel_msg.angular.z = 0停止机器人运动。
（4）更新下一次运动时间:在完成一个运动周期后，next_motion_time += DELTA_T更新下一次执行运动的时间点。


time_propagation ：该函数用于执行算法的状态传播更新
具体解释如下：
1、同步状态更新:使用state_lock和v_all_lock保证对状态和速度数据的同步访问，避免了并发访问的错误。
2、速度数据同步:从v_all中获取最新的速度数据（v_update），这代表了当前运动周期中的速度。
v_count_local存储了当前运动周期已更新到的步骤，用于与state_count中的计数器同步。
3、算法状态更新:针对每个算法实例，使用获取到的速度数据进行更新实现了基于实时速度数据的运动预测。
4、状态预测和存储:在每次更新后，将算法实例的最新预测状态（位置和协方差）存储到state_alg和cov_alg中，使用v_count_local + 1作为索引，确保了状态和预测之间的连续性。
5、状态计数器更新:state_count[0]用于跟踪当前运动周期的更新步骤，当所有算法均完成当前周期的更新后，计数器增加，以识别下一步的预测阶段。
6、通知更新完成:通过state_cond和state_cond.notify_all()机制，当状态更新完成时通知其他可能依赖此更新的组件或线程。

Measurement ：该函数根据标签获得的距离数据（mea）更新距离矩阵（mea_rela_all），并管理测量周期的时间同步
具体解释如下：
1、获取测量数据:mea = a.dis_list 从标签获取当前时刻的距离列表（dis_list）。
2、管理测量循环:通过rospy.get_time()和state_count[1] >= state_count[0]来检查当前的运动状态是否允许进行测量。只有在当个时间周期内，机器人运动结束且状态一步预测完成后，才会执行测量操作。
3、执行测量:当执行条件满足时，开始测量过程。通过measure_time与next_motion_time比较，确保在运动周期内进行测量。并更新下一次测量的时间点
4、存储测量结果:遍历距离列表（mea），并将其存储到mea_rela_all矩阵中。使用mea_count来跟踪当前填充的位置（每一行代表一个测量周期，每一列代表一个测量对象或标签）。


Mea_update :该函数根据上一个函数Measurement执行算法的量测更新
具体解释如下：
1、同步状态与测量:通过state_count和mea_count跟踪实时状态和测量的同步情况，确保在运动状态更新后才执行测量数据的融合，避免了不必要的同步开销。
2、测量数据处理:当测量数据更新时（mea_count > mea_count_local），处理来自不同传感器的测量数据（mea_rela_all），并对各个算法实例（algs_meas）的测量状态进行标记（algs_meas[type].measuring[r]）。
3、基于测量数据更新算法的状态（位置和协方差）
4、状态更新与存储:在测量更新完成（Need_Update为真）后，将当前运动状态（位置和协方差）存储到算法实例中，以便后续的预测和估计阶段（state_count[1] += 1）。
5、重置与准备下一次测量:调用各算法的rela_meas_correct()方法进行相对测量校正，然后重置相关状态以准备下一次测量周期

以下三个函数共同执行算法的通信更新部分
Comm_send：该函数主要作用是在多机器人系统中实现通信数据的实时发布与接收，以共享各机器人对环境的感知和估计结果。
具体解释如下：
1、通信周期管理:通过comm_interval定义通信周期，使用循环控制comm_times变量以按设定的频率进行通信周期的循环。
根据curr_comm_times与comm_interval的比较，确定当前是否达到通信周期，进而触发通信数据的发布。
2、初始化与参数同步:在第一次通信周期时，会初始化或更新与通信相关的参数，如广播历史记录(broadcast_comm_his_GS)。确保每个机器人都知道自己的通信频率和历史，以便进行正确的通信排序和同步。
3、通信数据的构建与发布:构建包含接收者ID、发送者ID、通信次数和算法状态/协方差的数据包，通过Float64MultiArray对象发布到特定话题上。根据算法状态和通信历史的实时更新，动态构造消息内容。
4、通信周期结束与数据存储:当所有机器人完成该通信周期的通信时，设置comm_complete为True，表示此周期的通信任务完成。更新与保存通信周期结束时的算法状态和协方差信息，用于下一次通信周期的准备。
5、循环与状态跟踪:根据comm_complete的判断，执行通信数据的存储和状态更新操作，以便为后续周期的通信做准备。

Comm_recv_callback：该函数主要负责处理多机器人系统中的通信接收过程，每台机器人接收到从其他机器人发送的通信数据后，进行处理和更新自己的状态估计。
具体解释如下：
1、通信数据验证：首先检查接收到的数据包是否是发给当前机器人的。如果不是，则直接忽略此数据包，不进行后续处理。
2、通信历史更新：在接收到的数据中，提取通信次数字段，以确定此数据是否是当前已知最新的通信数据。如果数据的通信次数小于当前记录的通信次数，那么忽略此数据包，认为它已过时。
3、数据接收和状态更新：如果数据包包含最新的通信信息，接收并存储这些数据。然后，使用接收到的信息更新当前机器人的状态估计（位置和协方差矩阵），并考虑对其进行通信一致性检验（can）。如果通信一致性检验成功，更新广播历史记录中的通信次数信息，表示已经接收到并处理了最新的通信数据。反之，如果通信检验失败，则更新广播历史记录中的通信次数信息，以标记为需要重新发送通信数据。
4、状态存储和同步：更新内部状态估计和协方差矩阵，同时保存这些数据供后续算法使用。这包括将这些数据存储回算法内部状态和协方差列表以及更新全局状态计数，以便其他算法模块可以同步并处理。

Comm_recv：该函数作用是在ROS环境中实现一个订阅者节点，用于接收来自其他节点的通信数据（以Float64MultiArray格式发布）。
具体解释如下：
1、订阅话题：使用rospy.Subscriber函数订阅名为comm的话题。这意味着它会监听并接收所有发布到comm话题的Float64MultiArray消息。
2、回调函数：为接收的数据包定义了一个回调函数Comm_recv_callback。每次接收到新消息时，该回调函数会被自动调用。回调函数内部包含了处理接收到的消息、更新自身状态和同步数据等逻辑。
3、循环监听：通过调用rospy.spin()函数进入一个无限循环，持续监听话题上的消息。这确保了节点在接收到新消息时，立即调用其订阅的回调函数处理消息。rospy.spin()是ROS中专门用于长时间运行且需要响应ROS消息的循环函数，它能够阻塞当前线程直到接收到新的消息或节点被关闭。

主函数：
通过threading.Thread函数创建线程，并通过thread_motion.join()将线程加入到队列中，由此实现整个算法各步骤的进行